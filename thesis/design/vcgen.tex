\subsection{VCGen}
\label{subsec:vcgen}

We want to have a verification condition generator that when given a FW-eBPF program $prog$, an initial machine state and a predicate representing the assumptions of all programs, i.e. that \texttt{r1} is initialized to contain a memory area, and \texttt{r2} is initialized to contain the size of the memory area in \texttt{r1} from which it is valid to read, and also guaranteed to be at least 1, i.e. $\forall r_1 . r_1 \geq 1$.


Using this initial predicate, we wish to extend it by iterating through the instructions in $prog$ one by one, extracting any needed verification conditions that are required to hold for the program if it satisfies the safety policy.

The final predicate $P$ should be $valid$, i.e. $\neg P$ should be unsatisfiable.
This will ensure that no matter the initial values in \texttt{r1} and \texttt{r2}, if a proof that $P$ is valid can be obtained, the program will never violate the safety policy.


% \subsubsection{Judgments}

% % \[
% % S \vdash K_1 / I / K_2 \hookrightarrow P
% % \]

% The main judgment of the system is

% \[
%   (P ,\sigma) \vdash I \hookrightarrow (P',\sigma')
% \]

% In this judgment, the pair $(P, \sigma)$ denotes a predicate $P$ and some machine state $\sigma$, $I$ denotes some FW-eBPF instruction and the pair $(P', \sigma')$ denotes a verification condition $P'$ and resulting machine state $\sigma'$, where $P'$ is a verification condition ensuring the instruction $I$ does not violate the safety policy if $I$ is executed in the machine state $\sigma$.






% The judgment for instructions is

% \[
%   \langle I, \sigma \rangle \downarrow (P,\sigma')
% \]



% \begin{prooftree}
%   \AxiomC{$\langle r_0, \sigma \rangle \downarrow e$}
%   % \RightLabel{$e \neq \mathrm{UNINIT}$}
%   \UnaryInfC{$\langle \mathrm{exit}, \sigma \rangle \downarrow (true, \sigma)$}
%   \end{prooftree}

% \begin{prooftree}
%   \AxiomC{$\langle o_s, \sigma \rangle \downarrow e$}
%   \UnaryInfC{$\langle \mathrm{mov} ~ r_d, o_s, \sigma \rangle \downarrow (\sigma(r_d) = e, \sigma[r_d \mapsto e])$}
%   \end{prooftree}
  






% \subsubsection{Machine State}


% The machine state $\sigma$ is a collection of symbolic expressions % and predicates
% representing the contents of the registers.  % and memory. 

% % The initial machine state has all registers uninitialised, except for \texttt{r1, r2} containing  respectively the context-pointer $m$ and size of memory $n$ and the frame-pointer $fp$ in \texttt{r10}.
% The initial machine state only contains variable for \texttt{r1, r2} containing  respectively the context-pointer $m$ and size of memory $n$, and the frame-pointer $fp$ in \texttt{r10}.

% % \begin{figure}[ht!]
% %   \centering
% \[
%   \text{Initial machine state} \sigma_0= \llbracket r_1 \mapsto m, r_2  \mapsto  n,  r_{10} \mapsto fp \rrbracket
% \]
%     % Initial machine state $\sigma_0=$ & $ \llbracket r_0 \mapsto \mathrm{UNINIT}, r_1 \mapsto m, r_2  \mapsto  n, r_3 \mapsto \mathrm{UNINIT}, r_4 \mapsto \mathrm{UNINIT},$ \\
%     %                                   & $~ r_5 \mapsto \mathrm{UNINIT}, r_6 \mapsto \mathrm{UNINIT}, r_7 \mapsto \mathrm{UNINIT}, r_8 \mapsto \mathrm{UNINIT}, r_9 \mapsto \mathrm{UNINIT},$ \\
%     % & $ ~  r_{10} \mapsto fp$ \\
%     % & $\rrbracket $ \\

% % \end{figure}



\subsubsection{Example Judgment}

As an example consider the below program. We want the generated verification condition for this program, line for line, to be the predicate on the right hand side.

\begin{tabular}{rll}
    & \textbf{Instruction} & \textbf{Resulting predicate}  \\
  0:& Before execution & $n \geq 1 \implies$ \\
  1:& \texttt{mov r0, 10} & $(\text{r0\_1} = 10 \implies $ \\
  2:& \texttt{mov r1, r2} & $(\text{r1\_2} = n \implies$  \\
  3:& \texttt{div r0, r1} & $(n \neq 0) \land (\text{r0\_3} = (\text{r0\_1} \oslash \text{r1\_2}) \implies$  \\
  4:& \texttt{exit} & $true)))$ \\
\end{tabular}

We will go through the instructions and resulting predicate line by line, informally reasoning about what parts we need in order to generate the verification condition we wish to obtain. Later we will formally define those parts.

The first line is not an instruction, but the initial predicate. We know (by design) that the register \texttt{r2} contains a value $n \geq 1$. 

Looking at the first instruction of the program, we want to turn \texttt{1: mov r0, 10} into $\text{r0\_1} = 10 \implies Q$, where $Q$ is some yet unknown predicate.

In order to turn the register \texttt{r0} into the variable \texttt{r0\_1}, we need some function to turn a \textit{destination register} at a specific \textit{line number} into a variable we can refer to in our predicate:
\[
newVar (n, r) = r + "\_" + n
\]

We need a way to represent a \textit{destination register} and a source operand, in this case an immediate integer constant.
Finally we need a rule that turns \texttt{lineno: mov rd, imm} into $\text{rd\_lineno} = imm$.

Looking at the second instruction, \texttt{2: mov r1, r2}, we want to turn it into $\text{r1\_2} = n$.
Where the first instruction has an immediate constant as the source operand, the second instruction has a register as the source operand. Our chosen representation of source operands must be either a numeral or a reference to a register.

We can obtain the variable r1\_2 using the $newVar$ function. The variable $n$ however, represents the value in register \texttt{r2} at the beginning of the program. We need a way of representing a \textit{machine state}, that maps registers to symbolic values.

To solve this, we introduce the store $\sigma$ to represent the \textit{machine state}. We have symbolic values for three registers at the beginning of every program, so we define the initial machine state as \[\sigma_0 = \llbracket r_1 \mapsto m, r_2 \mapsto n, r_{10} \mapsto fp \rrbracket \]

A lookup can be perfomed as $\sigma(r)$ and will yield a symbolic value. If the register $r$ is not present in the store, the result is undefined. 
A store can be extended as $\sigma[r \mapsto v]$, meaning the store $\sigma$, but with $\sigma(r)$ now yielding the symbolic value $v$.

We will need to obtain a new machine state that includes the new mapping, and can do so as $\sigma[rd \mapsto \sigma(rs)]$.

Finally we need a new rule that turns \texttt{lineno: mov rd, rs} into $\text{rd\_lineno} = \sigma(rs)$


The third instruction,  \texttt{3: div r0, r1} we want to turn into a conjunction, where the right hand side has the implication.


First looking at the left hand side of the predicate, $n \neq 0$.
Division by zero is not allowed in our safety policy, so whenever we have an unknown divisor, we need to assert the divisor is not 0. Thus we need a way to turn \texttt{div rd, rs} into $\sigma(rs) \neq 0$.
$n$ represents the value in register \texttt{r2} at the beginning of the program. In the previous instruction we assigned the value of the register \texttt{r2} to the register \texttt{r1}, and assuming we updated the store $\sigma$ accordingly, $\sigma(rs) = n$ should be taken care of. 


Looking at the right hand side of the predicate, $\text{r0\_3} = (\text{r0\_1} \oslash \text{r1\_2})$, we can obtain r0\_3 using the $newVar$ function. r0\_1 is the variable that represents the value in register \texttt{r0} \textit{before} execution of instruction 3, likewise r1\_2 for register \texttt{r1}. We need a way to obtain the last generated variable for a register.
To solve this, we introduce the store $\gamma$ to hold all introduced variables. $\gamma$ is a mapping between registers and stacks of variables.
$\gamma(r)$ will yield the stack of variables for the register $r$ and $\gamma[r \mapsto vs]$ means the store $\gamma$ but modified such that $\gamma(r)$ yields $vs$.

We introduce two auxiliary functions, one for obtaining the last declared variable for a register in a given store $\gamma$, and one for declaring a new variable for a register and modifying a given store $\gamma$ accordingly.
\[
  lastVar(r, \gamma) = PEEK (\gamma(r))
\]
\[
  withVar(n, r, \gamma) = \gamma[r \mapsto PUSH(newVar(n, r), \gamma(r))]
\]


The operator $\oslash$ I have chosen to represent unsigned 64 bit integer division.

We need a new rule that turns \texttt{lineno: div rd, rs} into the conjunction of the two predicates, as well as updating the store.

The last instruction, \texttt{4: exit} should be transformed into $true$. 


Finally, we need a way to combine the generated predicates. 


\subsubsection{Instruction Sequences}

We begin by defining how we represent instructions. 
% Elements $I$ denote instructions as the following:

\begin{figure}[H]
  \centering
  \begin{tabular}{ll}
    Labels & $L ::= N \in \mathbb{Z}^+$ \\
    Register & $R ::= r_0 ~|~ r_1 ~|~ r_2 ~|~ r_3 ~|~ r_4 ~|~ r_5 ~|~ r_6 ~|~ r_7 ~|~ r_8 ~|~ r_9 ~ | ~ r_{10}$ \\
    % Frame Pointer & $FP ::= r_{10}$ \\
    Immediate & $IMM \in 0..2^{32}-1$ \\
    % Source & $S ::= R ~ | ~ FP ~ | ~ IMM$ \\
  Source & $S ::= R  ~ | ~ IMM$ \\
  % Assembly Mnemonics & $A ::= \mathrm{mov} ~ R, S ~ | ~ \mathrm{add} ~ R, S ~ | ~ \mathrm{div} ~ R, S ~ | ~ \mathrm{sub} ~ R, S ~ | ~ \mathrm{xor} ~ R, S$ \\
    Assembly Mnemonics & $A ::= \mathrm{exit} ~ | ~ \mathrm{mov} ~ R, S ~ |  ~ \mathrm{div} ~ R, S$ \\
    Instruction & $I ::= L ~ : ~ A$\\
    Program & $P ::= \{ ~I~ \}$ \\
\end{tabular}    
  % \caption{}
  % \label{fig:instruction_sequences}
\end{figure}

A label is the one-indexed number of the instruction in the eBPF-program.
A Program is a sequence of instructions.

We define the read-only store $\Phi$ to be a mapping between line numbers and Instructions. 

\subsubsection{Expressions and predicates}
We continue by defining the syntax for expression and predicates.

% \begin{figure}[ht]
%   \centering
  \begin{tabular}{lrl}
    % Uninitialised Variables & $U ::= $ & $u_0 ~|~ u_3~|~ u_4~|~ u_5~|~ u_6~|~ u_7~|~ u_8~|~ u_9 $ \\
    Variables & $X \quad ~$ &\\
    Immediates & $N \quad ~$ & $\in \{0..2^{32}-1\}$  \\
    % Expressions & $E ::= $ & $N ~ | ~ \mathrm{UNINIT} ~ | ~ X ~ |$ \\
    Expressions & $E ::= $ & $N ~  | ~ X ~ | ~ E_1 \oslash E_2$ \\
              % & & $E_1 + E_2 ~ | ~ E_1 - E_2 ~ | ~ E_1 ~ \mathrm{div} ~ E_2 ~ | ~ E_1 ~ \mathrm{xor} ~ E_2 ~ |$ \\
              % & & $E_1 \oplus E_2 ~ | ~ E_1 \ominus E_2 ~ | ~ E_1 ~ \oslash ~ E_2 ~ | ~ E_1 ~ \otimes ~ E_2 ~ $ \\    
    % & & $sel(E_1, E_2) ~|~ upd(E_1, E_2, E_3)$ \\
    % Expression Predicates & $EP ::=$ & $true ~ | ~ false ~ | ~ E_1 = E_2 ~ | E_1 \neq E_2 ~ | ~ E_1 ~ \geq ~ E_2 ~ | ~ E_1 < E_2 ~ | ~ E \not \in U$ \\
    Expression Predicates & $EP ::=$ & $true ~ | ~ E_1 = E_2 ~ | E_1 \neq E_2 ~ | ~ E_1 ~ \geq ~ E_2 $ \\
    % Predicates & $P ::=$ & $EP ~ | ~ P_1 \land P_2 ~ | ~ P_1 \implies P_2 ~ | ~ \forall X.P$ \\
    Predicates & $P ::=$ & $EP ~ | ~ P_1 \land P_2 ~ | ~ P_1 \implies P_2$ \\
\end{tabular}    
% \end{figure}

In the syntax for expressions, the symbols have the following meaning:

\begin{figure}[ht]
  \centering
  \begin{tabular}{ll}
    % $\oplus$  & unsigned addition with 64-bit wrapping.\\
    % $\ominus$ & unsigned subtraction with 64-bit wrapping. \\
    $\oslash$ & unsigned division with 64-bit wrapping. \\
    % $\otimes$ & xor-operation with 64-bit wrapping. \\
    % $sel(E_1, E_2)$ & If $E_1$ describes memory state, returns the value stored in memory address $E_2$ \\
    % $upd(E_1, E_2, E_3)$ & In mem-state $E_1$, replace $[E_2]$ with value of $E_3$. \\
    \end{tabular}
\end{figure}







% \inputminted{text}{design/example_judgment.ebpf}


% \begin{prooftree}
%   \AxiomC{}
%   \UnaryInfC{$(P,\sigma_0) \vdash \mathrm{mov} ~ \mathrm{r0, 10}  ~ \hookrightarrow (P, \sigma_0[\sigma_0(r0) \mapsto 10])$}
% \end{prooftree}

% \begin{prooftree}
%   \AxiomC{}
%   \UnaryInfC{$(P,\sigma_0) \vdash \mathrm{mov} ~ \mathrm{r0, 10}  ~ \hookrightarrow (P, \sigma_0[\sigma_0(r0) \mapsto 10])$}
%   \AxiomC{$\sigma(r_2) \not \in U$}
%   \BinaryInfC{$(P,\sigma) \vdash \mathrm{div} ~ r_0, r_2 \hookrightarrow (P \implies (\sigma(r_2) \neq 0 \land (\sigma(r_0) \mapsto ))$}
% \end{prooftree}


% \begin{prooftree}
%   \AxiomC{}
%   \UnaryInfC{}
%   \UnaryInfC{$(P,\sigma) \vdash \mathrm{exit} ~ \hookrightarrow (P \implies true, \sigma)$}
% \end{prooftree}

% $$S_0 \vdash \cdot ~ / ~ \mathrm{mov} ~ r_0, 10 ~ / ~ \mathrm{mov} ~ r_1, 2 ~ ; ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow P$$
% where

% $$S_0 = \llbracket r_0 = x, r_1 = y, \dots \rrbracket$$
% and $x, y$ are unbound variables.

% \begin{prooftree}
%   \AxiomC{$S[r_0 \leftarrow 10] \vdash \mathrm{mov} ~ r_0, 10 ~/~  \mathrm{mov} ~ r_1, 2 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow P$}
%   \UnaryInfC{$S_0 \vdash \cdot ~ / ~ \mathrm{mov} ~ r_0, 10 ~ / ~ \mathrm{mov} ~ r_1, 2 ~ ; ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow P$}
% \end{prooftree}

% \begin{prooftree}
%   \AxiomC{$S[r_0 \leftarrow 10, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ / ~ \mathrm{div} ~ r_0, r_1 ~/~ \mathrm{exit} \hookrightarrow P$}  
%   \UnaryInfC{$S[r_0 \leftarrow 10] \vdash \mathrm{mov} ~ r_0, 10 ~/~ ~ \mathrm{mov} ~ r_1, 10 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow P$}
%   \UnaryInfC{$S_0 \vdash \cdot ~ / ~ \mathrm{mov} ~ r_0, 10 ~ / ~ \mathrm{mov} ~ r_1, 10 ~ ; ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow P$}
% \end{prooftree}


% \begin{prooftree}
%   \AxiomC{$S[r_0 \leftarrow x \oslash y, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ ; ~ \mathrm{div} ~ r_0, r_1 ~/~ \mathrm{exit} ~/~ \hookrightarrow Q$}  
%   \UnaryInfC{$S[r_0 \leftarrow 10, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}  
%   \UnaryInfC{$S[r_0 \leftarrow 10] \vdash \mathrm{mov} ~ r_0, 10 ~/~ ~ \mathrm{mov} ~ r_1, 10 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}
%   \UnaryInfC{$S_0 \vdash \cdot ~ / ~ \mathrm{mov} ~ r_0, 10 ~ / ~ \mathrm{mov} ~ r_1, 10 ~ ; ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}
% \end{prooftree}

% \begin{prooftree}
%   \AxiomC{$S[r_0 \leftarrow x \oslash y, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ ; ~ \mathrm{div} ~ r_0, r_1 ~/~ \mathrm{exit} ~/~ \cdot  \hookrightarrow true$}  
%   \UnaryInfC{$S[r_0 \leftarrow x \oslash y, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ ; ~ \mathrm{div} ~ r_0, r_1 ~/~ \mathrm{exit} ~/~ \hookrightarrow Q$}  
%   \UnaryInfC{$S[r_0 \leftarrow 10, r_1 \leftarrow 2] \vdash \mathrm{mov} ~ r_0, 10 ~;~  \mathrm{mov} ~ r_1, 2 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}  
%   \UnaryInfC{$S[r_0 \leftarrow 10] \vdash \mathrm{mov} ~ r_0, 10 ~/~ ~ \mathrm{mov} ~ r_1, 10 ~ / ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}
%   \UnaryInfC{$S_0 \vdash \cdot ~ / ~ \mathrm{mov} ~ r_0, 10 ~ / ~ \mathrm{mov} ~ r_1, 10 ~ ; ~ \mathrm{div} ~ r_0, r_1 ; \mathrm{exit} \hookrightarrow y \neq 0 \land Q$}
% \end{prooftree}



\subsubsection*{Derivation Rules for operands}
The judgment for \textit{operands}, i.e. $S$ in the syntax for instructions is

\[
  \langle S, \sigma \rangle \downarrow E
\]


An operand is either an immediate constant value, or a register.
If a register does not exist in $\sigma$, the operation is undefined.
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{S-IMM}
  \UnaryInfC{$\langle N,\sigma \rangle \downarrow N$}
\end{prooftree}



\begin{prooftree}
  \AxiomC{}
  \LeftLabel{S-REG}
  \UnaryInfC{$\langle R,\sigma \rangle \downarrow \sigma(R)$}
  \end{prooftree}


\subsubsection*{Derivation Rules for instructions}

The judgment for instructions is:
\[
\langle I, (\sigma,\gamma) \rangle \downarrow (P, \sigma', \gamma')
\]

Meaning if an instruction $I$ is symbolically executed with a machine state $\sigma$ and variable store $\gamma$, the result is a predicate $P$, a new machine state $\sigma'$ and a new variable store $\gamma'$.

% The judgment for instructions is:
% \[
% \langle I, (P,\sigma,\gamma) \rangle \downarrow (P', \sigma', \gamma')
% \]

% Meaning if an instruction $I$ is symbolically executed with a predicate $P$, a machine state $\sigma$ and variable store $\gamma$, the result is a new predicate $P'$, a new machine state $\sigma'$ and a new variable store $\gamma'$.



\begin{prooftree}
  \AxiomC{}
  \LeftLabel{EXIT-I}
  \UnaryInfC{$\langle L : \mathrm{exit}, (\sigma, \gamma) \downarrow (true, \sigma, \gamma)$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\langle IMM, \sigma \rangle \downarrow e$}
  \AxiomC{$withVar(n, r_d, \gamma) = \gamma'$}  
  \LeftLabel{MOV-IMM}
  \BinaryInfC{$\langle n: \mathrm{mov} ~r_d, IMM, (\sigma, \gamma) \downarrow (lastVar(r_d,\gamma') = e, \sigma [r_d \mapsto e], \gamma') $ }
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\langle r_s, \sigma \rangle \downarrow e$}
  \AxiomC{$withVar(n, r_d, \gamma) = \gamma'$}
  \LeftLabel{MOV-REG}
  \BinaryInfC{$\langle n: \mathrm{mov} ~r_d, r_s, (\sigma, \gamma) \downarrow (lastVar(r_d,\gamma') = e, \sigma [r_d \mapsto e], \gamma') $ }
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\langle r_d, \sigma \rangle \downarrow e_d$}
  \AxiomC{$\langle r_s, \sigma \rangle \downarrow e_s$}  
  \AxiomC{$withVar(n, r_d, \gamma) = \gamma'$}
  \LeftLabel{DIV-REG}
  \TrinaryInfC{$\langle n: \mathrm{div} ~r_d, r_s, (\sigma, \gamma) \downarrow ((e_s \neq 0) \land lastVar(r_d,\gamma') = lastVar(r_d,\gamma) \oslash lastVar(r_s,\gamma), \sigma [r_d \mapsto lastVar(r_d,\gamma')], \gamma') $ }
\end{prooftree}


\subsubsection*{Derivation Rules for Programs}

The judgment for Programs is:
\[
\langle \Phi, n, (P, \sigma, \gamma) \downarrow (P \implies Q, \sigma', \gamma')
\]

Meaning if a Program $\Phi$ beginning at line $n$ is symbolically executed with a predicate $P$, a machine state $\sigma$ and a variable store $\gamma$, the result is a new predicate $P \implies Q$, a new machine state $\sigma'$ and new variable store $\gamma'$.



\begin{prooftree}
  \AxiomC{$\Phi(n) \downarrow n : \mathrm{exit}$}
  \AxiomC{$\langle n : \mathrm{exit}, (\sigma, \gamma) \rangle \downarrow (true, \sigma, \gamma) $}
  \LeftLabel{ProgExit}
  \BinaryInfC{$\langle \Phi, n, (P, \sigma, \gamma) \rangle \downarrow (P \implies true, \sigma, \gamma)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Phi(n) \downarrow I_1$}
  \AxiomC{$\langle I_1, (\sigma, \gamma) \rangle \downarrow (Q'' \land Q', \sigma'', \gamma'')$}
  \AxiomC{$\langle \Phi, (n+1), (Q', \sigma'', \gamma'') \rangle \downarrow (Q, \sigma', \gamma')$}  
  \LeftLabel{ProgSeqDiv}
  \RightLabel{$(I_1 = n : \mathrm{div} ~ r_d, r_s)$}
  \TrinaryInfC{$\langle \Phi, n, (P, \sigma, \gamma) \rangle \downarrow (P \implies (Q'' \land Q), \sigma', \gamma')$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Phi(n) \downarrow I_1$}
  \AxiomC{$\langle I_1, (\sigma, \gamma) \rangle \downarrow (Q', \sigma'', \gamma'')$}
  \AxiomC{$\langle \Phi, (n+1), (Q', \sigma'', \gamma'') \rangle \downarrow (Q, \sigma', \gamma')$}  
  \LeftLabel{ProgSeq}
  \RightLabel{$(I_1 \neq n : \mathrm{exit})$}
  \TrinaryInfC{$\langle \Phi, n, (P, \sigma, \gamma) \rangle \downarrow (P \implies Q, \sigma', \gamma')$}
\end{prooftree}





\subsubsection*{Revisiting the example program}
Having now defined syntax, domains, judgments and derivation rules, we revisit the example program and derive the desired verification condition from it.
As the derivation tree will be very large if written out explicitly, I will construct subderivations for each step so the final tree fits on a single page. 


\begin{tabular}{ll}
  $\sigma_0 =$ & $\llbracket r_2 \mapsto "n" \rrbracket$ \\
  $\gamma_0 =$ & $\llbracket r_0 \mapsto [], r_1 \mapsto [], r_2 \mapsto ["n"] \rrbracket$ \\
  $\Phi =$ & $\llbracket 1 \mapsto \mathrm{mov} ~ r_0, 10, $ \\
               & $~2 \mapsto \mathrm{mov} ~ r_1, r_2, $ \\
               & $~3 \mapsto \mathrm{div} ~ r_0, r_1, $ \\
               & $~4 \mapsto \mathrm{exit} \rrbracket$ \\
  $P = $ & $n \geq 1$ \\
\end{tabular}


$\mathcal{I}_1 =$ 
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{S-IMM}
  \UnaryInfC{$\langle 10, \sigma_0 \rangle \downarrow 10$}
  \AxiomC{$withVar(1, r_0, \gamma_0) = \gamma_0[r_0 \mapsto ["r0\_1"]]$}
  \LeftLabel{MOV-IMM}
  \BinaryInfC{$\langle 1 : \mathrm{mov} ~ r_0, 10, (\sigma_0, \gamma_0) \rangle \downarrow ("r0\_1" = 10, \sigma_0[r_0 \mapsto 10], \gamma_0[r_0 \mapsto ["r0\_1"]] )$}
\end{prooftree}

We now have
\begin{tabular}{ll}
  $\sigma_1 =$ & $\llbracket r_2 \mapsto "n", r_0 \mapsto 10 \rrbracket$ \\
  $\gamma_1 =$ & $\llbracket r_0 \mapsto ["r0\_1"], r_1 \mapsto [], r_2 \mapsto ["n"] \rrbracket$ \\
  $Q_1 =$ & $"r0\_1" = 10$ \\
\end{tabular}


$\mathcal{I}_2 =$ 
\begin{prooftree}
  % \AxiomC{$\Phi(2) \downarrow I_2$}
  \AxiomC{}
  \LeftLabel{S-REG}
  \UnaryInfC{$\langle r_2, \sigma_1 \rangle \downarrow "n"$}
  \AxiomC{$withVar(2, r_1, \gamma_1) = \gamma_1[r_1 \mapsto ["r1\_2"]]$}
  \LeftLabel{MOV-REG}
  \BinaryInfC{$\langle 2 : \mathrm{mov} ~ r_1, r_2, (\sigma_1, \gamma_1) \rangle \downarrow ("r1\_2" = "n", \sigma_1[r_1 \mapsto "n"], \gamma_1[r_1 \mapsto ["r1\_2"]] )$}
  \end{prooftree}

We now have
\begin{tabular}{ll}
  $\sigma_2 =$ & $\llbracket r_2 \mapsto "n", r_0 \mapsto 10, r_1 \mapsto "n" \rrbracket$ \\
  $\gamma_2 =$ & $\llbracket r_0 \mapsto ["r0\_1"], r_1 \mapsto ["r1\_2"], r_2 \mapsto ["n"] \rrbracket$ \\
  $Q_2 =$ & $"r1\_2" = "n"$ \\  
\end{tabular}

$\mathcal{I}_3 =$ 
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{S-REG}
  \UnaryInfC{$\langle r_0, \sigma_2 \rangle \downarrow 10"$}
  \AxiomC{}
  \LeftLabel{S-REG}
  \UnaryInfC{$\langle r_1, \sigma_2 \rangle \downarrow "n"$}
  \AxiomC{$withVar(3, r_0, \gamma_2) = \gamma_2[r_0 \mapsto ["r0\_3", "r0\_1"]]$}
  \LeftLabel{DIV-REG}
  \TrinaryInfC{$\langle 3 : \mathrm{div} ~ r_0, r_1, (\sigma_2, \gamma_2) \rangle \downarrow (("n" \neq 0) \land ("r0\_3" = "r0\_1" \oslash "r1\_2")), \sigma_2[r_0 \mapsto "r0\_3"], \gamma_2[r_0 \mapsto ["r0\_3", "r0\_1"]])$}
  \end{prooftree}

  We now have
\begin{tabular}{ll}
  $\sigma_3 =$ & $\llbracket r_2 \mapsto "n", r_0 \mapsto "r0\_3", r_1 \mapsto "n" \rrbracket$ \\
  $\gamma_3 =$ & $\llbracket r_0 \mapsto ["r0\_3", "r0\_1"], r_1 \mapsto ["r1\_2"], r_2 \mapsto ["n"] \rrbracket$ \\
  $Q_3' =$ & $"n" \neq 0$ \\
  $Q_3'' =$ & $"r0\_3" = "r0\_1" \oslash "r1\_2" $ \\
  $Q_3 =$ & $Q_3' \land Q_3''$ \\  
\end{tabular}


$\mathcal{I}_4 =$ 
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{EXIT-I}
  \UnaryInfC{$\langle 4 : \mathrm{exit}, (\sigma_3, \gamma_3) \rangle \downarrow (true, \sigma_3, \gamma_3)$}
  \end{prooftree}

$\mathcal{R}_4 = \langle \Phi, 4, (Q_3'', \sigma_3, \gamma_3) \rangle \downarrow (Q_3'' \implies true, \sigma_3, \gamma_3)$ 
% \begin{prooftree}
%   \AxiomC{$\langle \Phi, 4, (Q_3'', \sigma_3, \gamma_3) \rangle \downarrow (Q_3'' \implies true, \sigma_3, \gamma_3)$}
%   \end{prooftree}

  We now have
\begin{tabular}{ll}
  $Q_4 =$ & $"r0\_3" = "r0\_1" \oslash "r1\_2" \implies true$
\end{tabular}

  
$\mathcal{R}_3 = \langle \Phi, 3, (Q_2, \sigma_2, \gamma_2) \rangle \downarrow (Q_2 \implies (Q_3' \land Q_4), \sigma_3, \gamma_3)$ 
% \begin{prooftree}
%   \AxiomC{$\langle \Phi, 3, (Q_2, \sigma_2, \gamma_2) \rangle \downarrow (Q_2 \implies (Q_3' \land Q_4), \sigma_3, \gamma_3)$}
%   \end{prooftree}

$\mathcal{R}_2 = \langle \Phi, 2, (Q_1, \sigma_1, \gamma_1) \rangle \downarrow (Q_1 \implies (Q_2 \implies (Q_3' \land Q_4))), \sigma_3, \gamma_3)$ 
% \begin{prooftree}
%   \AxiomC{$\langle \Phi, 2, (Q_1, \sigma_1, \gamma_1) \rangle \downarrow (Q_1 \implies (Q_2 \implies (Q_3' \land Q_4))), \sigma_3, \gamma_3)$}
%   \end{prooftree}

  We can finally build the final $Q$: \\
\begin{tabular}{ll}
  $Q =$ & $("r0\_1" = 10 \implies $ \\
        & $("r1\_2" = "n" \implies $ \\
        & $(("n" \neq 0) \land ("r0\_3" = "r0\_1" \oslash "r1\_2" \implies true))))$
\end{tabular}
  
  
% \begin{landscape}  
  \begin{prooftree}
    \AxiomC{$\Phi(1) \downarrow I_1$}
    % \noLine
  \AxiomC{$\mathcal{I}_1$}
  % \UnaryInfC{$\langle I_1, (\sigma_0, \gamma_0) \rangle \downarrow (Q_1, \sigma_1, \gamma_1)$}
  \AxiomC{$\Phi(2) \downarrow I_2$}
  % \noLine
  \AxiomC{$\mathcal{I}_2$}
  % \UnaryInfC{$\langle I_2, (\sigma_1, \gamma_1) \rangle \downarrow (Q_2, \sigma_2, \gamma_2)$}
  \AxiomC{$\Phi(3) \downarrow I_3$}
  \AxiomC{$\mathcal{I}_3$}
  \AxiomC{$\Phi(4) \downarrow I_4$}
  \AxiomC{$\mathcal{I}_4$}
  % \AxiomC{$\Phi(4) \downarrow 4 : \mathrm{exit}$}
  \RightLabel{ProgExit}
  \BinaryInfC{$\mathcal{R}_4$}
  % \UnaryInfC{$\langle \Phi, 4, (Q_3, \sigma_3, \gamma_3) \rangle \downarrow (Q_3 \implies true, \sigma_3, \gamma_3)$}
  \RightLabel{ProgSeqDiv}
  \TrinaryInfC{$\mathcal{R}_3$}
  \RightLabel{ProgSeq}
    \TrinaryInfC{$\mathcal{R}_2$}
  % \TrinaryInfC{$\langle \Phi, 2, (Q_1, \sigma_1, \gamma_1) \rangle \downarrow (Q_2, \sigma_4, \gamma_4)$}
  % \AxiomC{$\mathcal{I}_2$}  
  \RightLabel{ProgSeq}
  \TrinaryInfC{$\langle \Phi, 1, (n \geq 1, \sigma_0, \gamma_0) \rangle \downarrow (n \geq 1 \implies ("r0\_1" = 10 \implies Q, \sigma_3, \gamma_3)$}
\end{prooftree}


% \end{landscape}  