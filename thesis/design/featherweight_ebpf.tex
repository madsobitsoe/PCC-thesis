\subsection{Featherweight eBPF}
\label{subsec:featherweight_ebpf}
Will contain definition of the subset of eBPF I will be covering and working with.


Featherweight-eBPF is an IMP-like language representing a small subset of the eBPF ISA.

Main restrictions:
\begin{itemize}
\item Only 64-bit values and operations
  % \item No jumps or branching. Only straight-line programs.
  \item Only forward jumps are allowed in programs. No looping.
\item Along with a pointer to the program context (``some memory'') passed to the program in \texttt{r1}, the size of that memory that is valid to read is also passed in \texttt{r2}. 
\end{itemize}


% TODO: Should this be in background?
At the beginning of execution of all programs, assume that
\begin{itemize}
\item \texttt{r1} contains \texttt{*ctx}, a pointer to "some memory".
\item \texttt{r2} contains a 64-bit integer indicating the size of the memory pointed to by \texttt{r1}, i.e. reading bytes between \texttt{r1} and \texttt{r1+(r2-1)} are allowed
\item \texttt{r10} contains a frame pointer to 512 bytes of stack-space for the eBPF program
\item \texttt{r0}, \texttt{r3}, \texttt{r4}, \texttt{r5}, \texttt{r6}, \texttt{r7}, \texttt{r8} and \texttt{r9} are all "uninitialized", i.e. they have an unknown value at program start. In "proper eBPF" it is invalid to read an uninitialized register. In x86\_64 assembly, i.e. "jited eBPF", it is valid (but stupid in most cases).

\end{itemize}

At the end of all programs, \texttt{r0} will contain the return value. 
This means \texttt{r0} should be initialized before an exit-instruction is reached.

Ensuring registers are initialized before they are read is a security policy, not a safety policy.
Therefore it is not a part of the verification conditions I will generate. Instead the derivation rules will ensure a register read is valid, so programs violating this will not be ``well formed'' and will not produce a verification condition. 

% \subsubsection*{Instruction set}

% \begin{tabular}{|l|l|} \hline
%   \textbf{Assembly mnemonic} & \textbf{eBPF equivalent}  \\ \hline
%   $\mathrm{mov} ~ r_d, r_s$  & $\mathrm{mov64} ~ r_d, r_s$\\ \hline
%   $\mathrm{mov} ~ r_d, IMM$  &   $\mathrm{mov64} ~ r_d, IMM$\\ \hline  
%   $\mathrm{div} ~ r_d, r_s$  & $\mathrm{div64} ~ r_d, r_s $\\ \hline
%   $\mathrm{exit}$ &  \texttt{exit} \\ \hline  
    %   \end{tabular}



\subsubsection{Defining FWeBPF}


Expressions of FWeBPF are defined by the grammar
\begin{figure}[H]
  \centering
  \begin{tabular}{lclr}
    $e$ & $::=$ & $X$ & (A variable) \\
      & $|$ & $N$ & (An immediate value $\in 0..2^{32}-1$ ) \\
      % & $|$ & $R$ & (A register) \\
      % & $|$ & $e_1 = e_2$ & (Equality of two expressions) \\
      % & $|$ & $e_1 != e_2$ & (Inequality of two expressions) \\
      & $|$ & $e_1 \oplus e_2$ & (Unsigned addition of two expressions with 64-bit wrapping) \\    
      & $|$ & $e_1 \otimes e_2$ & (Unsigned multiplication of two expressions with 64-bit wrapping) \\    
      & $|$ & $e_1 \oslash e_2$ & (Unsigned division of two expressions with 64-bit wrapping) \\
      & $|$ & $e_1 ~ \mathrm{xor} ~ e_2$ & (bitwise \texttt{xor} of two expressions with 64-bit wrapping) \\        
\end{tabular}    
\end{figure}

Expression Predicates of FWeBPF are defined by the grammar
\begin{figure}[H]
  \centering
  \begin{tabular}{lclr}
    $ep$ & $::=$ & \texttt{true} & \\
     & $|$ & $e_1 = e_2$ & (Equality of two expressions) \\    
     & $|$ & $e_1 \neq e_2$ & (Inequality of two expressions) \\
     & $|$ &  $e_1 \geq e_2$ & (Greater than or equal of two expressions) \\
\end{tabular}    
\end{figure}


Instructions of FWeBPF are defined by the grammar
\begin{figure}[H]
  \centering
  \begin{tabular}{lclr}
    $i$ & $::=$ & \texttt{exit} & (Exits the program with \texttt{r0} as return value) \\
        & $|$   & $x := e$      & (assignment) \\
        % & $|$   & $s_1 ; s_2$   & (sequence) \\
        & $|$   & $\mathrm{if} ~ ep ~ \mathrm{then} ~ idx$ & (conditional) \\ %s_1 ~ \mathrm{else} ~ s_2$ & (conditional) \\
\end{tabular}    
\end{figure}

% Statements of FWeBPF are defined by the grammar
% \begin{figure}[H]
%   \centering
%   \begin{tabular}{lclr}
%     $s$ & $::=$ & \texttt{exit} & (Exits the program with \texttt{r0} as return value) \\
%         & $|$   & $x := e$      & (assignment) \\
%         & $|$   & $s_1 ; s_2$   & (sequence) \\
%         & $|$   & $\mathrm{if} ~ ep ~ \mathrm{then} ~ s_1 ~ \mathrm{else} ~ s_2$ & (conditional) \\
% \end{tabular}    
% \end{figure}


A program is a 0-indexed vector of instructions $\mathcal{P}$, st. the index corresponds to the line number of the instruction $n$ minus 1, i.e. $\mathcal{P}_0$ corresponds to the first instruction of the program, $\mathcal{P}_1$ to the second and so on.

\subsubsection{Translating eBPF to FWeBPF}

\begin{figure}[H]
  \centering
  \begin{tabular}{rcl}
    \textbf{eBPF assembly} & & \textbf{FWeBPF} \\
    \texttt{exit} & $=$ & \texttt{exit} \\
    $\mathrm{mov} ~ r_d, src$ & $=$ & $r_d := src$ \\
    $\mathrm{add} ~ r_d, src$ & $=$ & $r_d := r_d \oplus src$ \\
    $\mathrm{mul} ~ r_d, src$ & $=$ & $r_d := r_d \otimes src$ \\        
    $\mathrm{div} ~ r_d, src$ & $=$ & $r_d := r_d \oslash src$ \\
    $\mathrm{xor} ~ r_d, src$ & $=$ & $r_d := r_d ~ \mathrm{xor} ~ src$ \\            
    $\mathrm{jeq ~ r_d, src, +off}$ & $=$ & $\mathrm{if} ~ (r_d = src) ~ \mathrm{then} ~ \mathrm{off}$ \\
    $\mathrm{jneq ~ r_d, src, +off}$ & $=$ & $\mathrm{if} ~ (r_d \neq src) ~ \mathrm{then} ~ \mathrm{off}$ \\
    $\mathrm{jge ~ r_d, src, +off}$ & $=$ & $\mathrm{if} ~ (r_d \geq src) ~ \mathrm{then} ~ \mathrm{off}$    \\    
\end{tabular}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \begin{tabular}{rcl}
%     \textbf{eBPF assembly} & & \textbf{FWeBPF} \\
%     T(\texttt{exit} : $prog)$ & $=$ & \texttt{exit} \\
%     T($\mathrm{mov} ~ r_d, src : prog$ ) & $=$ & $r_d := src ; T(prog)$ \\
%     T($\mathrm{div} ~ r_d, r_s : prog$) & $=$ & $r_d := r_d \oslash r_s ; T(prog)$ \\
%     T($\mathrm{jeq ~ r_d, r_s, +off} : prog$) & $=$ & $\mathrm{if} ~ (r_d = r_s) ~ \mathrm{then} ~ T(prog[\mathrm{off}..]) ~ \mathrm{else} ~ T(prog)$ \\
% \end{tabular}    
% \end{figure}

