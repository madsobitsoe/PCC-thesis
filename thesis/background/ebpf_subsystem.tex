
\subsection{eBPF Subsystem}
\label{subsec:ebpf_subsystem}
Will cover learning objective ``Explain the eBPF subsystem, in particular the machine- and programming model''.

% \subsubsection{eBPF Machine Model}
\subsubsection{eBPF ISA}
\subsubsection{eBPF Programming Model}
\subsubsection{eBPF Verifier - actions and guarantees}
Will cover learning objective ``Explain the functionality of the eBPF verifier and what it guarantees''.
Will cover learning objective ``Analyze and identify problems related to untrusted code (and sandboxing?)''

% \paragraph{Bounded loops}
% Bounded loops are allowed, but with two main conditions:
% \begin{itemize}
% \item The user loading the program must have \texttt{BPF\_CAPABLE}. In older versions of the verifier, \texttt{env->allow\_pointer\_leaks} had to be set, which it would be when the loading user was privileged (sudo etc.).
%   TODO: Figure out why!
  

% \item The back-edge must not be inside a call?? As in, the \texttt{BPF\_PSEUDO\_CALL} instruction set the \texttt{loop\_ok} bool to false. 
% See \url{ https://github.com/torvalds/linux/blob/1e3778cb223e861808ae0daccf353536e7573eed/kernel/bpf/verifier.c#L6311}.
% \end{itemize}

% The analysis of loops builds a dominator tree \url{https://en.wikipedia.org/wiki/Dominator_(graph_theory)}.
% Apparently the analysis is based on induction, but the induction variable that controls a loop is found by pattern matching loop-patterns generated by LLVM?
% This might be valuable: \url{https://lwn.net/Articles/773605/}.

% The verifier then attempts to simulate the smallest and largest state of the variable, i.e. the first and last iteration, in order to not generate a new state for each iteration. (TODO: Confirm!).


% \subsubsection{BTF - eBPF Type Format}


