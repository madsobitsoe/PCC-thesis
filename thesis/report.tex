\input{skel}

\setAssignment{Masters Thesis - eBPF and PCC}
\title{\course\small{DIKU, 2022}}

\begin{document}
\maketitle

\hrulefill

\section{Introduction}
\label{sec:introduction}

\section{Background}
\label{sec:background}

\subsection{Crash course in the linux kernel architecture (brief)}
\label{subsec:crash_course_in_the_linux_kernel_architecture_(brief)}
Brief section giving a quick overview of the possibilities of extending the linux kernel, i.e. new kernel, new module or eBPF.


\subsection{eBPF Subsystem}
\label{subsec:ebpf_subsystem}
Will cover learning objective ``Explain the eBPF subsystem, in particular the machine- and programming model''.

\subsubsection{eBPF Machine Model}
\subsubsection{eBPF Programming Model}
\subsubsection{eBPF Verifier - actions and guarantees}
Will cover learning objective ``Explain the functionality of the eBPF verifier and what it guarantees''.
Will cover learning objective ``Analyze and identify problems related to untrusted code (and sandboxing?)''

\paragraph{Bounded loops}
Bounded loops are allowed, but with two main conditions:
\begin{itemize}
\item The user loading the program must have \texttt{BPF\_CAPABLE}. In older versions of the verifier, \texttt{env->allow\_pointer\_leaks} had to be set, which it would be when the loading user was privileged (sudo etc.).
  TODO: Figure out why!
  

\item The back-edge must not be inside a call?? As in, the \texttt{BPF\_PSEUDO\_CALL} instruction set the \texttt{loop\_ok} bool to false. 
See \url{ https://github.com/torvalds/linux/blob/1e3778cb223e861808ae0daccf353536e7573eed/kernel/bpf/verifier.c#L6311}.
\end{itemize}

The analysis of loops builds a dominator tree \url{https://en.wikipedia.org/wiki/Dominator_(graph_theory)}.
Apparently the analysis is based on induction, but the induction variable that controls a loop is found by pattern matching loop-patterns generated by LLVM?
This might be valuable: \url{https://lwn.net/Articles/773605/}.

The verifier then attempts to simulate the smallest and largest state of the variable, i.e. the first and last iteration, in order to not generate a new state for each iteration. (TODO: Confirm!).


\subsection{Proof Carrying Code}
\label{subsec:proof_carrying_code}

Will cover learning objective ``Explain what Proof Carrying Code is and explain the architecture behind''.



\subsubsection*{Draft diagram of PCC Architecture}

\begin{figure}[htbp!]
  \centering
\inputminted{text}{figures/pcc-architecture.txt}
  \caption{First draft of PCC Architecture}
  \label{fig:pcc-architecture}
\end{figure}





\section{Implementation}
\label{sec:implementation}

Will cover learning objective ``Modify and extend the linux kernel, in particular the eBPF subsystem.''
Will cover learning objective ``Write C-code for the linux kernel adhering to current guidelines and standards.''










\bibliographystyle{splncs04}
\bibliography{references}

\appendix
\end{document}
